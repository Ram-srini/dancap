// This is an autogenerated file based on the Intel SGX SDK file: sgx_error.h
// It "handles" an error by printing and returning false.
// In some cases the application could retry after these failures.
#include <iostream>
#include "sgx_error.h"

bool HandleSgxErr(sgx_status_t ret){
    using namespace std;
    if (ret == SGX_SUCCESS) { cout << "SUCCESS\n"; return(1);}
    cerr << hex;
    switch(ret){
    case SGX_ERROR_UNEXPECTED:
        cerr << "SGX_ERROR_UNEXPECTED: ";
        cerr << "Unexpected error\n";
        break;
    case SGX_ERROR_INVALID_PARAMETER:
        cerr << "SGX_ERROR_INVALID_PARAMETER: ";
        cerr << "The parameter is incorrect\n";
        break;
    case SGX_ERROR_OUT_OF_MEMORY:
        cerr << "SGX_ERROR_OUT_OF_MEMORY: ";
        cerr << "Not enough memory is available to complete this operation\n";
        break;
    case SGX_ERROR_ENCLAVE_LOST:
        cerr << "SGX_ERROR_ENCLAVE_LOST: ";
        cerr << "Enclave lost after power transition or used in child process created by linux:fork()\n";
        break;
    case SGX_ERROR_INVALID_STATE:
        cerr << "SGX_ERROR_INVALID_STATE: ";
        cerr << "SGX API is invoked in incorrect order or state\n";
        break;
    case SGX_ERROR_FEATURE_NOT_SUPPORTED:
        cerr << "SGX_ERROR_FEATURE_NOT_SUPPORTED: ";
        cerr << "Feature is not supported on this platform\n";
        break;
    case SGX_ERROR_INVALID_FUNCTION:
        cerr << "SGX_ERROR_INVALID_FUNCTION: ";
        cerr << "The ecall/ocall index is invalid\n";
        break;
    case SGX_ERROR_OUT_OF_TCS:
        cerr << "SGX_ERROR_OUT_OF_TCS: ";
        cerr << "The enclave is out of TCS\n";
        break;
    case SGX_ERROR_ENCLAVE_CRASHED:
        cerr << "SGX_ERROR_ENCLAVE_CRASHED: ";
        cerr << "The enclave is crashed\n";
        break;
    case SGX_ERROR_ECALL_NOT_ALLOWED:
        cerr << "SGX_ERROR_ECALL_NOT_ALLOWED: ";
        cerr << "The ECALL is not allowed at this time, e.g. ecall is blocked by the dynamic entry table, or nested ecall is not allowed during initialization\n";
        break;
    case SGX_ERROR_OCALL_NOT_ALLOWED:
        cerr << "SGX_ERROR_OCALL_NOT_ALLOWED: ";
        cerr << "The OCALL is not allowed at this time, e.g. ocall is not allowed during exception handling\n";
        break;
    case SGX_ERROR_STACK_OVERRUN:
        cerr << "SGX_ERROR_STACK_OVERRUN: ";
        cerr << "The enclave is running out of stack\n";
        break;
    case SGX_ERROR_UNDEFINED_SYMBOL:
        cerr << "SGX_ERROR_UNDEFINED_SYMBOL: ";
        cerr << "The enclave image has undefined symbol.\n";
        break;
    case SGX_ERROR_INVALID_ENCLAVE:
        cerr << "SGX_ERROR_INVALID_ENCLAVE: ";
        cerr << "The enclave image is not correct.\n";
        break;
    case SGX_ERROR_INVALID_ENCLAVE_ID:
        cerr << "SGX_ERROR_INVALID_ENCLAVE_ID: ";
        cerr << "The enclave id is invalid\n";
        break;
    case SGX_ERROR_INVALID_SIGNATURE:
        cerr << "SGX_ERROR_INVALID_SIGNATURE: ";
        cerr << "The signature is invalid\n";
        break;
    case SGX_ERROR_NDEBUG_ENCLAVE:
        cerr << "SGX_ERROR_NDEBUG_ENCLAVE: ";
        cerr << "The enclave is signed as product enclave, and can not be created as debuggable enclave.\n";
        break;
    case SGX_ERROR_OUT_OF_EPC:
        cerr << "SGX_ERROR_OUT_OF_EPC: ";
        cerr << "Not enough EPC is available to load the enclave\n";
        break;
    case SGX_ERROR_NO_DEVICE:
        cerr << "SGX_ERROR_NO_DEVICE: ";
        cerr << "Can't open SGX device\n";
        break;
    case SGX_ERROR_MEMORY_MAP_CONFLICT:
        cerr << "SGX_ERROR_MEMORY_MAP_CONFLICT: ";
        cerr << "Page mapping failed in driver\n";
        break;
    case SGX_ERROR_INVALID_METADATA:
        cerr << "SGX_ERROR_INVALID_METADATA: ";
        cerr << "The metadata is incorrect.\n";
        break;
    case SGX_ERROR_DEVICE_BUSY:
        cerr << "SGX_ERROR_DEVICE_BUSY: ";
        cerr << "Device is busy, mostly EINIT failed.\n";
        break;
    case SGX_ERROR_INVALID_VERSION:
        cerr << "SGX_ERROR_INVALID_VERSION: ";
        cerr << "Metadata version is inconsistent between uRTS and sgx_sign or uRTS is incompatible with current platform.\n";
        break;
    case SGX_ERROR_MODE_INCOMPATIBLE:
        cerr << "SGX_ERROR_MODE_INCOMPATIBLE: ";
        cerr << "The target enclave 32/64 bit mode or sim/hw mode is incompatible with the mode of current uRTS.\n";
        break;
    case SGX_ERROR_ENCLAVE_FILE_ACCESS:
        cerr << "SGX_ERROR_ENCLAVE_FILE_ACCESS: ";
        cerr << "Can't open enclave file.\n";
        break;
    case SGX_ERROR_INVALID_MISC:
        cerr << "SGX_ERROR_INVALID_MISC: ";
        cerr << "The MiscSelct/MiscMask settings are not correct\n";
        break;
    case SGX_ERROR_INVALID_LAUNCH_TOKEN:
        cerr << "SGX_ERROR_INVALID_LAUNCH_TOKEN: ";
        cerr << "The launch token is not correct\n";
        break;
    case SGX_ERROR_MAC_MISMATCH:
        cerr << "SGX_ERROR_MAC_MISMATCH: ";
        cerr << "Indicates verification error for reports, sealed datas, etc\n";
        break;
    case SGX_ERROR_INVALID_ATTRIBUTE:
        cerr << "SGX_ERROR_INVALID_ATTRIBUTE: ";
        cerr << "The enclave is not authorized\n";
        break;
    case SGX_ERROR_INVALID_CPUSVN:
        cerr << "SGX_ERROR_INVALID_CPUSVN: ";
        cerr << "The cpu svn is beyond platform's cpu svn value\n";
        break;
    case SGX_ERROR_INVALID_ISVSVN:
        cerr << "SGX_ERROR_INVALID_ISVSVN: ";
        cerr << "The isv svn is greater than the enclave's isv svn\n";
        break;
    case SGX_ERROR_INVALID_KEYNAME:
        cerr << "SGX_ERROR_INVALID_KEYNAME: ";
        cerr << "The key name is an unsupported value\n";
        break;
    case SGX_ERROR_SERVICE_UNAVAILABLE:
        cerr << "SGX_ERROR_SERVICE_UNAVAILABLE: ";
        cerr << "Indicates aesm didn't respond or the requested service is not supported\n";
        break;
    case SGX_ERROR_SERVICE_TIMEOUT:
        cerr << "SGX_ERROR_SERVICE_TIMEOUT: ";
        cerr << "The request to aesm timed out\n";
        break;
    case SGX_ERROR_AE_INVALID_EPIDBLOB:
        cerr << "SGX_ERROR_AE_INVALID_EPIDBLOB: ";
        cerr << "Indicates epid blob verification error\n";
        break;
    case SGX_ERROR_SERVICE_INVALID_PRIVILEGE:
        cerr << "SGX_ERROR_SERVICE_INVALID_PRIVILEGE: ";
        cerr << "Enclave has no privilege to get launch token\n";
        break;
    case SGX_ERROR_EPID_MEMBER_REVOKED:
        cerr << "SGX_ERROR_EPID_MEMBER_REVOKED: ";
        cerr << "The EPID group membership is revoked.\n";
        break;
    case SGX_ERROR_UPDATE_NEEDED:
        cerr << "SGX_ERROR_UPDATE_NEEDED: ";
        cerr << "SGX needs to be updated\n";
        break;
    case SGX_ERROR_NETWORK_FAILURE:
        cerr << "SGX_ERROR_NETWORK_FAILURE: ";
        cerr << "Network connecting or proxy setting issue is encountered\n";
        break;
    case SGX_ERROR_AE_SESSION_INVALID:
        cerr << "SGX_ERROR_AE_SESSION_INVALID: ";
        cerr << "Session is invalid or ended by server\n";
        break;
    case SGX_ERROR_BUSY:
        cerr << "SGX_ERROR_BUSY: ";
        cerr << "The requested service is temporarily not availabe\n";
        break;
    case SGX_ERROR_MC_NOT_FOUND:
        cerr << "SGX_ERROR_MC_NOT_FOUND: ";
        cerr << "The Monotonic Counter doesn't exist or has been invalided\n";
        break;
    case SGX_ERROR_MC_NO_ACCESS_RIGHT:
        cerr << "SGX_ERROR_MC_NO_ACCESS_RIGHT: ";
        cerr << "Caller doesn't have the access right to specified VMC\n";
        break;
    case SGX_ERROR_MC_USED_UP:
        cerr << "SGX_ERROR_MC_USED_UP: ";
        cerr << "Monotonic counters are used out\n";
        break;
    case SGX_ERROR_MC_OVER_QUOTA:
        cerr << "SGX_ERROR_MC_OVER_QUOTA: ";
        cerr << "Monotonic counters exceeds quota limitation\n";
        break;
    case SGX_ERROR_KDF_MISMATCH:
        cerr << "SGX_ERROR_KDF_MISMATCH: ";
        cerr << "Key derivation function doesn't match during key exchange\n";
        break;
    case SGX_ERROR_UNRECOGNIZED_PLATFORM:
        cerr << "SGX_ERROR_UNRECOGNIZED_PLATFORM: ";
        cerr << "EPID Provisioning failed due to platform not recognized by backend serve\n";
        break;
    case SGX_ERROR_UNSUPPORTED_CONFIG:
        cerr << "SGX_ERROR_UNSUPPORTED_CONFIG: ";
        cerr << "The config for trigging EPID Provisiong or PSE Provisiong&LTP is invali\n";
        break;
    case SGX_ERROR_NO_PRIVILEGE:
        cerr << "SGX_ERROR_NO_PRIVILEGE: ";
        cerr << "Not enough privilege to perform the operation\n";
        break;
    case SGX_ERROR_PCL_ENCRYPTED:
        cerr << "SGX_ERROR_PCL_ENCRYPTED: ";
        cerr << "trying to encrypt an already encrypted enclave\n";
        break;
    case SGX_ERROR_PCL_NOT_ENCRYPTED:
        cerr << "SGX_ERROR_PCL_NOT_ENCRYPTED: ";
        cerr << "trying to load a plain enclave using sgx_create_encrypted_enclave\n";
        break;
    case SGX_ERROR_PCL_MAC_MISMATCH:
        cerr << "SGX_ERROR_PCL_MAC_MISMATCH: ";
        cerr << "section mac result does not match build time mac\n";
        break;
    case SGX_ERROR_PCL_SHA_MISMATCH:
        cerr << "SGX_ERROR_PCL_SHA_MISMATCH: ";
        cerr << "Unsealed key MAC does not match MAC of key hardcoded in enclave binary\n";
        break;
    case SGX_ERROR_PCL_GUID_MISMATCH:
        cerr << "SGX_ERROR_PCL_GUID_MISMATCH: ";
        cerr << "GUID in sealed blob does not match GUID hardcoded in enclave binary\n";
        break;
    case SGX_ERROR_FILE_BAD_STATUS:
        cerr << "SGX_ERROR_FILE_BAD_STATUS: ";
        cerr << "The file is in bad status, run sgx_clearerr to try and fix it\n";
        break;
    case SGX_ERROR_FILE_NO_KEY_ID:
        cerr << "SGX_ERROR_FILE_NO_KEY_ID: ";
        cerr << "The Key ID field is all zeros, can't re-generate the encryption key\n";
        break;
    case SGX_ERROR_FILE_NAME_MISMATCH:
        cerr << "SGX_ERROR_FILE_NAME_MISMATCH: ";
        cerr << "The current file name is different then the original file name (not allowed, substitution attack)\n";
        break;
    case SGX_ERROR_FILE_NOT_SGX_FILE:
        cerr << "SGX_ERROR_FILE_NOT_SGX_FILE: ";
        cerr << "The file is not an SGX file\n";
        break;
    case SGX_ERROR_FILE_CANT_OPEN_RECOVERY_FILE:
        cerr << "SGX_ERROR_FILE_CANT_OPEN_RECOVERY_FILE: ";
        cerr << "A recovery file can't be opened, so flush operation can't continue (only used when no EXXX is returned) \n";
        break;
    case SGX_ERROR_FILE_CANT_WRITE_RECOVERY_FILE:
        cerr << "SGX_ERROR_FILE_CANT_WRITE_RECOVERY_FILE: ";
        cerr << "A recovery file can't be written, so flush operation can't continue (only used when no EXXX is returned) \n";
        break;
    case SGX_ERROR_FILE_RECOVERY_NEEDED:
        cerr << "SGX_ERROR_FILE_RECOVERY_NEEDED: ";
        cerr << "When openeing the file, recovery is needed, but the recovery process failed\n";
        break;
    case SGX_ERROR_FILE_FLUSH_FAILED:
        cerr << "SGX_ERROR_FILE_FLUSH_FAILED: ";
        cerr << "fflush operation (to disk) failed (only used when no EXXX is returned)\n";
        break;
    case SGX_ERROR_FILE_CLOSE_FAILED:
        cerr << "SGX_ERROR_FILE_CLOSE_FAILED: ";
        cerr << "fclose operation (to disk) failed (only used when no EXXX is returned)\n";
        break;
    case SGX_ERROR_UNSUPPORTED_ATT_KEY_ID:
        cerr << "SGX_ERROR_UNSUPPORTED_ATT_KEY_ID: ";
        cerr << "platform quoting infrastructure does not support the key\n";
        break;
    case SGX_ERROR_ATT_KEY_CERTIFICATION_FAILURE:
        cerr << "SGX_ERROR_ATT_KEY_CERTIFICATION_FAILURE: ";
        cerr << "Failed to generate and certify the attestation key\n";
        break;
    case SGX_ERROR_ATT_KEY_UNINITIALIZED:
        cerr << "SGX_ERROR_ATT_KEY_UNINITIALIZED: ";
        cerr << "The platform quoting infrastructure does not have the attestation key available to generate quote\n";
        break;
    case SGX_ERROR_INVALID_ATT_KEY_CERT_DATA:
        cerr << "SGX_ERROR_INVALID_ATT_KEY_CERT_DATA: ";
        cerr << "The data returned by the platform library's sgx_get_quote_config() is invalid\n";
        break;
    case SGX_ERROR_PLATFORM_CERT_UNAVAILABLE:
        cerr << "SGX_ERROR_PLATFORM_CERT_UNAVAILABLE: ";
        cerr << "The PCK Cert for the platform is not available\n";
        break;
    default:
        cerr << "UNKNOWN SGX ERROR:" << ret << "\n";
    }
    cerr << dec;
    return(false);
}
